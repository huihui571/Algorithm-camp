## 0-1背包问题
### 问题描述
给你一个可装载重量为W的背包和N个物品，每个物品有重量和价值两个属性。其中第i个物品的重量为wt[i]，价值为val[i]，现在让你用这个背包装物品，最多能装的价值是多少？

例如：
```
N = 3, W = 4
wt = [2, 1, 3]
val = [4, 2, 3]
```
算法返回 6，选择前两件物品装进背包，总重量 3 小于W，可以获得最大价值 6。

### 动态规划标准套路

#### 第一步，明确「状态」和「选择」
只要给定几个可选物品和一个背包的容量限制，就形成了一个背包问题，对不对？所以状态有两个，就是「**背包的容量**」和「**可选择的物品**」。   
对于每件物品，你能选择什么？选择就是「**装进背包**」或者「**不装进背包**」嘛。   
明确了状态和选择，剩下的只要往这个动态规划框架里套就行了：
```
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)
```

#### 第一步，明确dp数组的定义
dp数组是什么？其实就是描述问题局面的一个数组。换句话说，我们刚才明确问题有什么「状态」，现在需要用dp数组把状态表示出来。刚才找到的「状态」，有两个，也就是说我们需要一个二维dp数组，一维表示可选择的物品，一维表示背包的容量。
   
**dp[i][w]的定义如下：对于前i个物品，当前背包的容量为w，这种情况下可以装的最大价值是dp[i][w]**。   

根据这个定义，我们想求的最终答案就是dp[N][W]。base case就是dp[0][...] = dp[...][0] = 0，因为没有物品或者背包没有空间的时候，能装的最大价值就是0。

#### 第三步，根据「选择」，思考状态转移的逻辑
对于每一个物品i，我们有两个选择：
1. **不把第i个物品装入背包**，那么显然，最大价值dp[i][w]应该等于dp[i - 1][w]。不装嘛，那就继承之前的结果。
2. **把第i个物品装入背包**，那么dp[i][w]应该等于dp[i - 1][w - wt[i - 1]] + val[i - 1]。首先，由于i是从 1 开始的，所以对val和wt的取值是i-1。然后，在装第i个物品的前提下，等于在第i-1个物品，剩余容量为w-wt[i-1]限制下能装的最大价值，再加上第i个物品的价值val[i-1]。
 
### 代码模板
```(c++)
int knapsack(int W, int N, vector<int>& wt, vector<int>& val) {
    //vector默认初始化为0，base case已初始化
    vector<vector<int>> dp(N + 1, vector<int>(W + 1))；
    for (int i = 1; i <= N; i++) {
        for (int w = 1; w <= W; w++) {
            if (w - wt[i - 1] < 0) {
                //当前背包容量装不下，只能选择不装
                dp[i][w] = dp[i - 1][w];
            }
            else {
                //装入或不装入，择优
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - wt[i - 1]] + val[i - 1]);
            }
        }
    }

    return dp[N][W];
}
```