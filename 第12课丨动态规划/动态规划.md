## 代码思路
1. 定义dp数组
2. 初始化dp数组
3. 遍历求状态转移方程
4. 取结果

## dp数组定义
数组的每一个元素表示一个“状态”，每一个维度表示一个独立的约束条件，
通常有[问题规模]、[限制条件1]、[限制条件2]...[状态]
Note: 局部最优解不一定直接是总体最优解。
      所以要明确dp[i]的含义，即：子问题0...i的解。所以最终解可能是dp[n-1]，也可能是max_of(dp[])

## 状态转移
每做一次选择，就会导致当前状态向下一状态或向自身的状态转移，
当前状态 = 择优(选择1, 选择2, ...)


## 动态规划
动态规划和递归或者分治没有根本上的区别（关键看有无最优子结构）
共性：找到重复子问题
差异性：最优子结构、中途可以淘汰次优解

## 关键点
1. 最优子结构 opt[n]=best_of(opt[n-1], opt[n-2], ...)
2. 存储中间状态：opt[i]
3. 递推公式(状态转移方程或DP方程)
    斐波那切：opt[i] = opt[i-1] + opt[i-2]
    二维路径：opt[i,j] = opt[i+1][j] + opt[i][j+1] (需判断a[i][j]是否是空地)

## 递推与递归
递归：先从start走一步，问题转化为从start+1到end的子问题。n->n-1
递推：先从end相邻的子问题出发，然后把子问题扩大一步。n->n+1

